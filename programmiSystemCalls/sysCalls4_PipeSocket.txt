sysCalls per comunicazione sulla stessa macchina (con file pipe): 1) pipe (per pipe senza nome), 2) fpathconf, 3) pathconf 4) write, 5) read, 6) close, 7) stat, 8) dup, 9) dup2, 10) mkfifo. Le #include necessarie sono: unistd.h.
0.00) Pipe senza nome (unnamed): sono file speciali senza nome usati per la comunicazione tra processi che condividono dei puntatori alla tabella dei file aperti (e quindi condividono la tabella dei descrittori che infatti contiene i puntatori ai file aperti) ==> ovvero: hanno grado di parentela! Infatti se piu' processi condividono uno stesso puntatore significa che hanno un padre in comune (ad esempio).
0.01) Pipe con nome (named o FIFO): sono file speciali con nome visibile a tutti i processi senza grado di parentela ma della stessa macchina.
0.02) A cosa servono le pipe: connettono unidirezionalmente due processi con un canale di comunicazione.
0.03) Comunicazione Unidirezionale: con uno o piu' scrittori ed un solo lettore.
01.0) Sintassi: int pipe(int pfd[2]) --> pfd[2]: sono due descrittori di file --> effects: crea un pipe senza nome (pfd[0]: descrittore che punta allo stdin, pfd[1]: descrittore che punta allo stdout) --> return: 0 in caso di successo, altrimenti -1 (e setta errno).
01.1) Come usare i pfd: pfd[1] ==> serve per scrivere sui file, pfd[0] ==> serve per leggere dai file.
01.2) Creazione pipe: int pfd[2];   pipe(pfd);
01.3) Capacita' della pipe: capacita' >= _POSIX_PIPE_BUF (di tipo long).
01.4) write(): funziona solo se il numero di byte scritti sul file sono <= della capacita' del pipe.
02.0) Sintassi: long fpathconf(int fd, int name) --> fd: file descriptor (per accesso al file) --> name: gli si puo' passare la variabile _PC_PIPE_BUF --> return: capacita' della pipe sul pc corrente (di tipo long), altrimenti -1 (settiamo errno = 0 prima del controllo perche' il -1 puo' essere inteso come "capienza illimitata" se errno rimane invariato, altrimenti c'e' stato un errore)
03.0) Sintassi: long pathconf(char *path, int name) --> path: percorso del file --> return: capacita' della pipe sul pc corrente (di tipo long), altrimenti -1 (settiamo errno = 0 prima del controllo perche' il -1 puo' essere interpretato come "capienza illimitata" se errno rimane invariato, altrimenti c'e' stato un errore)
04.0) Sintassi: int write(int *pfd, const void *buf, int n) --> *pfd: di solito gli si passa pfd[1] contenente il file descriptor dello stdout (quindi write scrive sullo stdout) --> *buf: puntatore al buffer contenente il messaggio da scrivere il quale puo' essere anche una stringa const scritta al posto dell'argomento stesso (es1: char* msg[n];   int x = write(pfd[1],msg,n);  es2: int x = write(pfd[1],"ciao\n",5);) --> n: numero di byte da scrivere nel file --> return: numero di byte scritti nel file, altrimenti -1 se O_NONBLOCK e' settato (e setta errno a EAGAIN) oppure per mancanza di lettori in ascolto (i descrittori di lettura sono stati chiusi). Quest'ultimo causa la terminazione del processo!
04.1) Attenzione: se tutti i descrittori di lettura sono stati chiusi, e quindi non esiste nessun lettore in pfd, viene inviato il segnale SIGPIPE al processo. Il processo gestisce il segnale interrompendo il processo! Dobbiamo ridefinire la gestione di tale segnale (vedremo quando parlaremo dei segnali).
04.2) Descrittore di lettura: la write si aspetta di trovare almeno un descrittore di lettura aperto da cui leggere i caratteri da scrivere.
05.0) int read(int *pfd, const void *buf, int n) --> *pfd: di solito gli si passa pfd[0] contenente il file descriptor dello stdin (quindi andiamo a leggere dallo stdin) --> *buf: puntatore alla zona di memoria in cui salviamo momentaneamente cio' che leggiamo dal file descriptor indicato con la pipe pfd per poi passarlo al write per la scrittura --> n: numero massimo di byte che legge la read --> return: numero di byte letti (max n), altrimenti 0 nel caso in cui i descrittori di scrittura siano tutti chiusi oppure -1 nel caso in cui O_NONBLOCK sia settato (e setta errno a EAGAIN)
05.1) Descrittore di scrittura: il read si aspetta di trovare almeno un descrittore di scrittura aperto al quale poter inviare i caratteri da scrivere. Infatti la read si mette in attesa di altri input se c'e' almeno un descrittore di scrittura aperto, ma se sono tutti chiusi da errore e ritorna 0 (EOF ==> end_of_file).
06.0) Sintassi: int close(int *pfd) --> *pfd: di solito pfd[0] o pfd[1], ma in generale un puntatore a un descrittore --> effects: libera il descrittore di file passatogli --> return: 0 in caso di successo (con conseguente liberazione del file descriptor), altrimenti -1 in caso di errore (e setta errno??)
06.1) Oss: se si fa la close sull'ultimo file descriptor di scrittura le read in attesa termineranno e ritorneranno 0.
06.2) Oss: se si fa una write su una pipe in cui tutti i file descriptor di lettura sono stati chiusi il processo viene terminato per segnale SIGPIPE (con ritorno -1 della write).
06.3) Usare write, read e close: --> 1) il processo padre crea la pipe e poi il processo figlio con una fork (possono essere anche piu' figli, basta ci sia un solo processo lettore) --> 2) nel processo figlio vengono copiati i file descriptor del padre che quindi puo' usare --> 3) il processo scrittore dei due chiude pfd[0] (lo stdin), mentre il processo lettore chiude pfd[1] (lo stdout) --> 4) i processi comunicano con read e write --> 5) finita la comunicazione il processo scrittore chiude anche pfd[1] e il processo lettore chiude anche pfd[0] --> VEDERE ESEMPIO PAG.20 DELLE SLIDE 19 PER CAPIRE.
04.5.6.) Riassunto: chi legge chiude il file descriptor della scrittura e chi scrive chiude il file descriptor della lettura. A quel punto si possono invocare rispettivamente la read e la write per la comunicazione tha processi.
07.0) Sulle slide dice solo che serve per vedere se un file e' una pipe --> per altre info cerca: man stat.
08.0) Sintassi: int dup(int fd) --> fd: indice del file descriptor su cui vogliamo ridirigere stdin/stdout --> effects: duplica il descrittore fd nel primo descrittore libero della tabella dei descriptor file (con dup(3) scrive in 4 perche' e' il primo libero) --> return: in caso di successo l'indice del file descriptor in cui abbiamo copiato il valore, altrimenti -1 (e setta errno)
09.0) Sintassi: int dup2(int fd, int fd2) --> fd: indice del file descriptor che vogliamo copiare --> fd2: indice del file descriptor in cui copiare fd --> effects: il file descriptor fd viene copiato nella posizione fd2 --> return: in caso di successo fd2, altrimenti -1 (e setta errno)
09.1) Esempi: dup2(3,1) ==> ridirige lo stdout (1) al file puntato dal file descriptor 3 --> dup2(4,2) ==> ridirige il file descriptor 2 nel file puntato dal file descriptor 4 (quindi ridirige lo stderr sul file puntato dal fd 4 e l'effetto e' che l'errore viene scritto sul file puntato dal fd 4)
09.3) Esempio Pipelining:  int pfd[2];   if(pipe(pfd)==-1){...}   dup2(pfd[1],1) ==> ridirige lo stdout (1) con la pipe pfd --> dup2(pfd[0],0); ==> ridirige lo stdin (e quindi indica allo stdin dove andare a leggere) sulla pipe pfd
09.4) Cosa deve fare la Pipe: ridirigere lo stdout nello stdin.
10.0) Sintassi: int mkfifo(const char *path, mode_t perms) --> *path: nome che verra' assegnato alla pipe --> perms: permessi di accesso (con uso della maschera "umask") ==> se passo 0664 permetto la scrittura sulla pipe anche da parte degli altri processi del mio gruppo ==> se gli passo 0666 non permette la scrittura agli altri processi del mio gruppo --> effects: crea una pipe col nome indicato e con permessi "perms" --> return: in caso di successo 0, altrimenti -1 (e setta errno)
10.1) A che serve: per creare pipe con nome (per ora abbiamo fatto solo quelle senza nome).
10.2) Visibilita' della pipe: il nome e' visibile da tutti i processi della stessa macchina (quindi tutti i processi possono comunicare con essa).
10.3) Controllo diritti di scrittura: int chmod(const char *path, int perms) --> *path: nome della pipe (gia' esistente) --> perms: permessi di accesso --> effects: controlla se su quella pipe ci sono quei diritti di accesso oppure no --> return: -1 se i permessi della pipe sono diversi da quelli indicati (e setta errno)
10.4) Uso della pipe con nome: 1) si deve fare la open() sulla pipe (in contemporanea) sia da un lettore che da uno scrittore: --> lo scrittore invoca la open e attende che ci sia almeno un lettore che la esegue a sua volta --> il lettore invoca la open e si mette in attesa se non c'e' almeno uno scrittore che l'ha invocata. 2) Le opzioni da usare con la open nello scrittore sono O_NONBLOCK e O_NDELAY, mentre nel lettore se vengono usate le stesse opzioni farebbe terminare la open se non ci fossero scrittori in attesa (termina con successo, non da errore).
10.5) Uso client-server: 1) il server crea la pipe e la apre sia in lettura che in scrittura (perche' quando sono finiti i client, per chiusura di tutti gli scrittori, il server farebbe la read e uscirebbe per EOF _end-of-file_ ==> cosi c'e' sempre un file aperto in scrittura per non far terminare la read). Inoltre il server dovra' fare un while(true) con una read all'interno per leggere dal client. 2) i client aprono la pipe in scrittura (in genere c'e' una pipe privata per ogni client-server).

sysCalls per comunicazione sulla stessa macchina (con file socket): 11) socket, 12) bind, 13) listen, 14) accept, 15) connect, 16) select. Le #include sono: sys/socket.h, sys/un.h.
0.1) Def Socket: file speciali usati perconnettere 2 o piu' processi tra loro.
0.2) Diff Socket-Pipe: 1) la socket permette comunicazione seriale. 2) per effettuare sulla socket le operazioni che sulla pipe erano open e mkfifo, servono altre syscalls (e inoltre sono di piu').
0.3) Come collegare due processi col socket: Nel Server: 1) sfd = socket(...); ==> crea un file speciale (il socket) e alloca il suo file descriptor. 2) bind(sfd,"indirizzoDiReteServer",...); ==> associa al file descriptor un indirizzo di rete (se tra "..." c'e' un path allora il canale di comunicazione e' sulla stessa macchina). 3) listen(sfd,...); ==> permette connessioni da parte di altri processi (siamo cioe' "in ascolto"). 4) accept(sfd,...); ==> blocca il processo in attesa di connessioni da parte di altri processi. --> Nel Client: 1) csfd = socket(...); ==> crea un file speciale (il socket) e alloca il suo file descriptor. 2) connect(csfd,"indirizzoDiReteServer",...); ==> permette di collegarsi all'indirizzo di rete del server specificato tra "" e se avviene un match (tra accept e connect) allora viene creato un nuovo socket privato il cui file descriptor viene restituito dall'accept nel server (nel client e' csfd). --> ADESSO LA COMUNICAZIONE PUO' AVVENIRE COME NEL PIPE ==> ATTRAVERSO WRITE, READ E CLOSE.
0.4) Come collegare n client ad un server: Nel server dobbiamo contemporaneamente: stare in attesa per nuove connessioni con un accept() e stare in attesa con una read() per eventuali messaggi dai client gia' connessi. SOLUZIONI: 1) usare un serve multithread con: 1 thread dispatcher contenente la accept (per nuove connessioni) e 1 thread worker con la read (per ricevere messaggi dal client). 2) usare un server sequenziale (ovvero che esegue il tutto in sequenza) con la sysCall select() (che permette di capire quali sono i file descriptor pronti evitando attese inutili (guarda 16.0).
0.5) Problema Big/Little Endian: se comunichiamo tra macchine diverse con una sequenza di byte e le macchine hanno endian diverso ci possono essere problemi e passare i byte invertiti 2 a 2 (D0 4C ==> 4C D0). Soluzione: usare un ordine dei byte indipendente dalla macchina, ovvero il network byte order. In pratica avviene una conversione dall'host byte order al network byte order e il ricevente del messaggio fara' l'opposto, quindi converitira' dal network byte order all'host byte order. OSS: La conversione non e' necessaria per file con formato definito ma solo per dati binari grezzi.
11.0) Sintassi: int socket(int domain, int type, int protocol) --> domain: dominio delle macchine di rete (che deve essere uguale a quello usato nella bind) ==> noi usiamo AF_UNIX o PF_UNIX per lavorare su una sola macchina, AF_INET per lavorare con piu' macchine --> type: tipo di connessione (dipende dal dominio, noi usiamo il tipo di connessione "connected") ==> noi usiamo SOCK_STREAM o SOCK_DGRAM per ora --> protocol: protocollo (dipende dal dominio) ==> passando 0 scegliamo il protocollo di default --> effects: crea un server socket (che corrispondera' al thread corrente) --> return: in caso di successo il file descriptor del socket, altrimenti -1 (e setta errno)
12.0) Sintassi: int bind(int sock_fd, const struct sockaddr *sa, socklen_t sa_len) --> sock_fd: file descriptor del socket --> *sa: possiamo passargli una stringa contenente il path dell'indirizzo solo se gli altri processi sono sulla stessa macchina, altrimenti dovremo considerarlo un puntatore alla struttura dati contenente l'indirizzo di accesso al server (gli va passato come indicato in 12.1) --> sa_len: dimensione della stringa passatagli (o della struttura) ==> e' un sizeof(sa) --> effects: assegna l'indirizzo passato (se nella stessa macchina e' un path) al socket sock_fd (in AF_UNIX assegna un nome nuovo perche' non possiamo assegnare nomi esistenti) --> return: 0 in caso di successo, altrimenti -1 (e setta errno)
12.1) struct sockaddr: Possiamo usare la struct sockaddr_un includendo sys/un.h. Dobbiamo fare gli stessi identici passaggi che ci sono a pagina 19/20 della slide 20.
13.0) Sintassi: int listen(int sock_fd, int backlog) --> sock_fd: file descriptor del socket --> backlog: numero massimo di connessioni in coda (massimo possibile: SOMAXCONN) --> effects: segnala che il socket e' pronto per accettare connessioni --> return: 0 in caso i successo, altrimenti -1 (e setta errno)
14.0) Sintassi: int accept(int sock_fd, const struct sockaddr *sa, socklen_t sa_len) --> sock_fd: file descriptor del socket --> *sa: indirizzo del socket che ha accettato la connessione (per sapere chi si e' connesso) ==> ha senso se fatto su macchine diverse (su INET) --> sa_len: lunghezza della struttura (se e' un path sara' il numero di caratteri) ==> se != NULL viene modificato con l'indirizzo del socket che ha accettato la connessione --> effects: si mette in attesa sul descrittore sock_fd finche' non avviene la connessione (grazie alla connect nel client) creando un nuovo socket per comunicare col client --> return: file descriptor del nuovo socket creato per la comunicazione, altrimenti -1 (e setta errno)
14.1) *sa: se gli passiamo NULL (e quindi sa_len sara' 0) non viene restituito niente ma ritorna comunque il fd del socket creato.
15.0) Sintassi: int connect(int sock_fd, const struct sockaddr *sa, socklen_t sa_len) --> sock_fd: file descriptor del socket appartenente al server con cui fare match (fara' match con la accept) --> *sa: indirizzo pubblico del server (che ha usato nel bind) --> sa_len: dimensione di sa (sizeof(sa)) --> effects: permette la connessione al server che ha fatto la accept con lo stesso file descriptor del socket --> return: 0 in caso di successo, altrimenti -1 (e setta errno a ENOENT se il server non e' ancora pronto)
15.1) Uso della connect: di solito viene messa in un while perche' non e' detto che la socket nel servere sia gia' pronta (nel while meglio mettere anche uno sleep(1) nel caso il server non sia pronto ==> se il server non e' pronto errno sara' = a ENOENT!) ==> ESEMPIO A PAGINA 29-30 DELLE SLIDE 20.
16.0) Sintassi: int select(int nfds, fd_set *rdset, fd_set *wrset, fd_set *errset, struct timeval *timeout) --> nfds: numero dei descrittori su cui leggere, scrivere e settare gli errori --> *rdset: insieme dei descrittori da cui aspetto dati in lettura --> *wrset: insieme dei descrittori in cui scrivere dati --> *errset: insieme dei descrittori in cui settare gli errori relativi alle letture/scritture --> *timeout: vedremo poi --> return: in caso di successo il numero di bit settati, altrimenti -1 (e setta errno)
16.1) Funzionamento: aspetta finche' qualcuno non e' pronto ad inviare o ricevere dati.
16.2) Utilita': evita attese indefinite in quanto dice quali sono i file descritpor pronti per la lettura o la scrittura.
16.3) Uso e informazioni su fd_set: sono maschere di bit (1 bit per ogni fd, es: secondo fd ==> posizione 1 della maschera) che possiamo manipolare con delle macro: --> FD_ZERO(&fdset) ==> azzera la maschera fdset (che ricordiamo essere un insieme di file descritpor) --> FD_SET(fd,&fdset) ==> mette a 1 il bit corrispondente al file descriptor fd della maschera fdset --> FD_CLR(fd,&fdset) ==> mette a 0 il bit corrispondente al file descriptor fd della maschera fdset --> FD_ISSET(fd,&fdset) ==> ritorna 1 se il bit corrispondente al file descriptor fd della maschera fdset e' settato a 1, altrimenti ritorna 0 --> UTILIZZO: azzero tutti i bit di una maschera, setto a 1 tutti i bit dei file descritpor con cui voglio comunicare (perche' sono pronti) e poi uso la read o la write se FD_ISSET() ritorna 1
16.4) Esempio di codice completo: pagine 41/42/43 slide 20.
16.5) Esempio sulle maschere: maschera 01001111 (la cui struttura e' nella struct fd_set) ==> la select ascolta i file descriptor 1,4,5,6,7 e ignora i file descriptor 0,2,3.

sysCalls per comunicazione su macchine diverse: 17) htons, 18) htonl, 19) ntohs, 20) ntohl. Serve l'inclusione di: arpa/inet.h.
00.0) AF_INET: Ogni indirizzo AF_INET e' formato da: --> 1) Un numero identificativo su rete internet di una macchina --> E' a 32 bit --> Usano la dotted notation: conversione (ogni 4 byte) in numero decimale e separati da punti ==> es: 216.109.125.70 --> La dotted notation e' associata ad un nome simpolico (www.unipi...) --> 2) Un numero identificativo della porta all'interno della macchina --> E' a 16 bit --> Identifica un servizio (es: 80 ==> http, 21 ==> server ftp, ecc..)
17.0) Sintassi: uint16_t htons(uint16_t hostnum) --> hostnum: numero di 16 bit di tipo host byte order definito cosi ==> uint16_t num = 0xD04C; --> effects: traduce il valore inserito di tipo uint16_t da host byte order a network byte order --> return: il valore convertito in network byte order (non puo' ritornare un errore)
18.0) Sintassi: uint32_t htonl(uint32_t hostnuml) --> hostnuml: numero su 32 bit di tipo host byte order definito cosi ==> uint32_t num = 0xAB43CD21; --> effects: converte il numero da host byte order a network byte order --> return: il valore di tipo uint32_t convertito in network byte order (non puo' ritornare un valore d'errore)
18.1) Codice di utilizzo:	uint16_t num = 0xCDEF;		unsigned char *p;	p = (unsigned char*) &n;	printf("%x",*p);	==> stampa: CDEF
19.0) Sintassi: uint16_t ntohs(uint16_t netnum) --> netnum: numero su 16 bit di tipo network byte order (ottenuto dalla chiamata di htons) --> effects: converte il numero da network byte order a host byte order --> return: il numero convertito in host byte order (non puo' ritornare un valore d'errore)
20.0) Sintassi: uint32_t ntohl(uint32_t netnuml) --> netnuml: numero su 32 bit di tipo network byte order (ottenuto dalla chiamata di htonl) --> effects: converte il numero da network byte order a host byte order --> return: il numero in host byte order (non puo' ritornare un valore d'errore)

sysCalls in realta' non sono system calls ma struct per rappresentare indirizzi AF_INET (per comunicazione tra piu' macchine): 21) sockaddr_in, 22) in_addr. Serve l'inclusione: netinet/in.h.
21.0) Sintassi: struct sockaddr_in { sa_family_t sin_family;	in_port_t sin_port;	struct in_addr sin_addr; }; --> sin_family: indirizzo AF_INET con le proprieta' viste al punto 00.0 --> sin_port: numero di porta di tipo uint16_t (network byte order) --> sin_addr: indirizzo IPv4 (descritto nel punto successivo 22.0
22.0) Sintassi: struct in_addr { in_addr_t s_addr; }  --> Premessa: struct usata come campo della struct sockaddr_in (vedere 21.0) --> s_addr: indirizzo di tipo uint32_t (network byte order)
22.1) Esempio di utilizzo:	struct sockaddr_in sa;		sa.sin_family = AF_INET; //numero di porta di tipo uint16_t (in net bo) --> sa.sin_port = htons(80); // indirizzo IPv4 di tipo uint32_t (in net bo) --> sa.sin_addr.s_addr = htonl(216<<24) + htonl(119<<16) + htonl(125<<8) + htonl(70); --> /* Oppure in alternativa: sa.sin_addr.s_addr = inet_addr("216.109.125.70"); ==> la funzione inet_addr converte l'indirizzo da dotted notation a 32 bit (procedimento inverso con inet_ntoa) */
22.2) OSS: se vogliamo collegarci ad un server web dobbiamo usare la porta 80 in quanto porta standard di rete.

