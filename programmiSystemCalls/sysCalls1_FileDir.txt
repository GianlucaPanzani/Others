0.0)Proprieta' generali delle SC: 1) ad ogni invocazione dobbiamo gestire il possibile errore, 2) All'interno dell'if e' opportuno mettere una perror (del tipo perror("tipo di errore")) seguita da una exit (del tipo exit(EXIT_FAILURE)), 3) ogni SC scrive su "errno" (0 --> se va tutto bene) il quale va testato subito perche' viene sovrascritto ad ogni chiamata di funzione.

sysCalls: 1) open, 2) read, 3) write, 4) close, 5) unlink, 6) lseek, 7) stat, 8) opendir, 9) closedir, 10) readdir, 11) rewinddir, 12) getcwd. Le #include sono: sys/types.h, sys/stat.h, fcntl.h, unistd.h, sys/stat.h, dirent.h
01.0) Sintassi: int open(const char* pathname, int flags, mode_p permission) --> pathname: percorso per il file --> flags: O_RDONLY (sola lettura), O_WRONLY (sola scrittura) e O_RDWR (sia letture che scrittura), O_APPEND (sola scrittura in fondo al file), O_CREAT (se il file non esiste lo crea), ecc --> permission: indica i diritti ma si puo' omettere se non dobbiamo creare il file (se esiste gia'). --> return: un intero che indica il descrittore del file (ovvero l'indice della tabella dei descrittori dei file nello spazio utente che contiene tutti gli indirizzi ai file aperti; la dimensione della tabella vale: _POSIX_OPEN_MAX), oppure in caso d'errore ritorna -1 e setta errno.
01.1) Descrittore di file: riferimento nella tabella dei descrittori dei file (a livello utente) che punta ad un file aperto nella tabella dei file aperti (a livello kernel). Il file aperto conterra' un puntatore all'i-node del file corrispondente.
01.2) Cosa fa la open: segue il path del file per arrivare all'i-node, confronta i flags passati coi diritti di accesso, se consente l'accesso allora assegna al file l'indice della prima posizione libera nella tabella dei descrittori dei file e a quel punto restituisce l'indice di quella posizione, altrimenti da errore (-1) e setta errno.
01.3) Cos'e' e cosa contiene un i-node: struttura dati usata per rappresentare un file. Si trova nella tabella degli i-node attivi (accessibile dal file aperto corrispondente nella tabella dei file aperti). Contiene: tipo del file, tipo di protezione (r-w-x), ID utente (uid), ID gruppo (gid), tempo di creazione/modifica (size), contatore per i link hard (numero di directory che puntano a quell'i-node), indirizzo (diretto) dei primi 10 blocchi del file, indirizzi dei blocchi indiretti (al piu' 3), ID del driver e del dispositivo al quale riferisce, path del file.
01.4) Organizzazione di una directory: ad albero. Cartelle: --> "." = figlio --> ".." = padre
01.5) Esempio: open("pathFile", O_CREAT | O_RDWR, 0666) --> 0666 = 000 110 110 110 (se presi 0,6,6,6 separatamente). Serve per limitare i diritti del file. Se scriviamo su terminale "umask" ci da un valore in ottale: 0022 (quasi sempre). Questo valore e' 000 000 010 010 e, attraverso l'operazione bit a bit: permission & ~umask = 0666 & ~0022, otteniamo i valori di diritti del file 000 110 100 100 = --- rw- r-- r-- = lettura/scrittura per noi, lettura per tutti gli altri.
02.0) Sintassi: int read(int fd, void* buffer, size_t nbytes) --> fd: file descriptor che permette l'accesso ai byte da leggere --> *buffer: puntatore che indica dove scrivere i dati letti --> nbytes: numero di byte da leggere --> return: numero di byte letti o -1 in caso di errore (e setta errno).
03.0) Sintassi: int write(int fn, const void* buffer, size_t nbytes) --> fd: file descriptor che permette l'accesso al file in cui andare a scrivere i dati --> *buffer: puntatore ai dati da scrivere nel file --> nbytes: numero di byte da scrivere sul file --> return: il numero di byte scritti oppure -1 in caso di errore (e setta errno).
04.0) Sintassi: int close(int fd) --> fd: file descriptor da chiudere --> effects: libera la posizione corrispondente nella tabella dei descrittori, libera la posizione del file nella tabella dei file aperti ed eventualmente l'i-node corrspondente (ma non libera il buffer cache con la fflush, quindi almeno una parte del file puo' essere ancora letta). --> return: 0 in caso di successo, -1 in caso di errore (e setta errno).
05.0) Sintassi: int unlink(cont char* pathname) --> pathname: percorso del file --> return: 0 in caso di successo, altrimenti -1 (e setta errno).
05.1) Cosa fa unlink: elimina un link del file passato per argomento e decrementa il contatore dell'hard link nell'i-node. Se il contatore e' = 0 significa che non ci sono link per quel file (al quale quindi non possiamo piu' accedere) e quindi viene eliminato il file stesso. Non funziona con le directory. Utile quando creiamo un file --> subito dopo la open() chiamiamo la unlink() sul file creato in modo tale da permettere l'eliminazione del file in modo automatico a fine processo.
06.0) Sintassi: off_t lseek(int fd, off_t offset, size_t whence) --> fd: file descriptor in cui stabilire il posizionamento (per preparare il file a lettura/scrittura) --> offset: spostamento in byte dalla posizione stabilita dall'argomento whence --> whence: puo' essere: SEEK_SET (inizio file), SEEK_CUR (posizione corrente) e SEEK_END (fine file). OSS: con offset = 0 si va esattamente nella pos stabilita da whence.
07.0) Sistassi: int stat(const char *path, struct stat *buf) --> *path: puntatore al percorso (o nome) del file --> *buf: puntatore a struct stat (7.1 per vedere che contiene la struct) --> return: 0 in caso di successo, altrimenti -1 (e setta errno).
07.1) Cosa contiene struct stat: st_ino --> il numero dell'i-node, st_mode --> i diritti di protezione, st_nlink --> il numero di hard link, st_uid --> Id dell'utente che usa la struct, st_size --> lunghezza totale del file, st_atime --> ultimo accesso al file, st_mtime --> ultima modifica, st_ctime --> ultima variazione dell'i-node.
07.2) Sintassi fstat: int fstat(int fd, struct stat *buf) --> e' uguale alla stat ma cambia il tipo di accesso al file. In questo caso avviene tramite file descriptor, nell'altro caso attraverso pathname.
07.3) Macro per la gestione di struct stat: .... le faremo.
08.0) Sintassi: DIR* opendir(const char *path) --> *path: percorso o nome per arrivare alla directory per poi aprirla --> return: puntatore alla directory (di struttura DIR) in caso di successo, altrimenti NULL (e setta errno).
08.1) Oss: quando viene aperta una directory con opendir() viene restituito un puntatore alla struct DIR. Funziona esattamente come l'apertura di un file con fopen(). Infatti DIR e' una struttura molto simile (quasi identica) alla struttura FILE.
09.0) Sintassi: int closedir(DIR* dirp) --> dirp: puntatore alla directory --> return: 0 in caso di successo, altrimenti -1 (e setta errno).
10.0) Sintassi: struct dirent* readdir(DIR* dirp) --> dirp: puntatore alla directory --> return: puntatore alla struttura dirent che descrive il file successivo nella directory passata, altrimenti NULL se finisce i file nella dir (e NON setta errno) oppure NULL in caso di errore ( e setta errno).
10.1) Come distiguere il tipo di ritorno NULL di readdir: facciamo l'assegnamento "errno=0" prima della chiamata di readdir e, in caso di ritorno = NULL, controlliamo se errno e' cambiata. Se errno e' != 0 significa che si e' verificato un errore, altrimenti sono semplicemente finiti i file nella directory.
10.2) Come usare readdir: se messa in un while restituisce di volta in volta il puntatore alla struct dirent contenente le informazioni del file successivo. Continueranno le iterazioni finche' non finisce i file. Esempio: DIR* d;	struct dirent *file;	d = opendir(".");	file = readdir(d);
10.3) Cosa contiene dirent: d_ino --> numero dell'i-node, *d_name --> stringa contenente il nome del file (ma non il pathname contenente il percorso).
12.0) Sintassi: char* getcwd(char *buf, size_t bufsize) --> *buf: stringa in cui salva il pathname della dir corrente (perche' poi ci spostiamo in un'altra dir con chdir() perdendo il path corrente, serve per poi tornare nella dir corrente cosi: chdir(buf)) --> bufsize: dimensione della stringa buf --> return: pathname in caso di successo, altrimenti NULL (e setta errno) con errore causato da dimensione di buf insufficiente a contenere il pathname (possiamo quindi riallocare buf con dimensione maggiore).
12.1) Come cambiare directory corrente: si usano le funzioni di libreria unistd.h: chdir e fchdir. Sintassi della prima: int chdir(const char *path) --> *path: stringa contenente il percorso della nuova directory corrente --> return: 0 in caso di successo, altrimenti -1 (e setta errno). Sintassi della seconda: int fchdir(int fd) --> fd: file descriptor della nuova directory che permette l'accesso al path --> return: 0 in caso di successo, altrimenti -1 (e setta errno).

0.0) SC vs stdio calls: meglio fopen, fread, ecc per file di piccole dimensioni, ma piu' veloci le SC per file piu' grandi.
