sysCalls: 1) getpid, 2) getppid, 3) fork, 4) exec(proprieta'), 5) execl, 6) exit, 7) _exit, 8) wait, 9) waitpid. Le #include necessarie sono: unistd.h, sys/wait.h, sys/types.h.
01.0) Sintassi: pid_t getpid() --> return: ID del processo in esecuzione (non puo' dare errore). Esempio: fprintf(stdout, "Il pid del processo e': %d", (int)getpid());
02.0) Sintassi: pid_t getppid() --> return: ID del processo padre rispetto a quello in esecuzione (non puo' dare errore).
03.0) Sintassi: pid_t fork() --> effect: crea un processo, figlio del chiamante, avente la copia di: codice del padre, spazio di indirizzamento del padre (vedi 3.1), tabella dei descrittori di file. Pero' hanno in comune la tabella dei file aperti --> return: nel figlio 0, nel padre l'ID del figlio, altrimenti-1 in caso di errore (e setta errno).
03.1) Spazio di indirizzamento: e' come un programma c vede la memoria che ha a disposizione. E' formato da cinque aree: Stack (pila di FRAME: 1 frame per ogni chiamata di funzione), area vuota, Heap (variabili allocate dinamicamente), Data (variabili globali) e Text (testo del programma tradotto in codice macchina). Oss: le funzioni, quando terminano, vengono deallocate dallo stack e scrive su questo il valore di ritorno. Quindi il ritorno di fork() e' su due stack diversi: su quello del processo padre e su quello del processo figlio.
03.2) fflush(): funzione che esegue cio' che c'e' nel buffer (se non e' stato eseguito e poi lo svuota. il tipo di gestione del buffer piu' usata al giorno d'oggi e' detta Fully Buffered (anche se ci sarebbero altri 2 tipi). Un buffer di questo tipo copia i caratteri del file in esecuzione in blocchi di dim pari alla dim del buffer e di volta in volta eseguiamo quel numero di istruzioni. Se pero' il buffer non si riempie non viene svuotato immediatamente. Quindi se non chiamiamo la funzione fflush() dopo una fork, questa copia anche il buffer nel processo figlio insieme alle istruzioni precedenti alla fork. E di conseguenza potrebbero essere eseguite nuovamente le operazioni presenti nel buffer (dal figlio) prima di passare alle istruzioni successive.
03.3) Eccezione "copy on write": la fork() non sarebbe efficiente perche' la maggior parte delle volte il codice copiato dal padre al figlio viene poi sovrascritto con del codice diverso attraverso la syscall exec (4.0). Quindi il segmento Text viene messo come condiviso tra i due processi in sola lettura. Se il padre o il figlio cercano di modificare il testo vengono messi in attesa e viene generata l'eccezione "copy on write" che verra' gestita copiando il testo nel processo figlio in modo tale da permettere ai due processi di modificare il proprio testo senza avere ripercussioni nell'altro.
04.0) Per "exec" intendiamo una famiglia di funzioni. Quindi le varie system calls sono descritte da 5.0 in poi.
04.1) A che servono le exec: permettono di reinizializzare lo spazio di indirizzamento del processo figlio con un altro file eseguibile in modo tale da permettere al figlio di avere codice diverso dal padre (e quindi di fare cose diverse).
04.2) Differenze tra le exec: fanno tutte la stessa cosa ma cambiano gli argomenti.
04.3) Conseguenze Differenziazione del testo: Il file eseguibile e' contraddistinto dagli altri file esguibili da un "Magic Number" (tipo un ID). Inoltre ha quattro sezioni: informazioni verie, Ampiezza BSS (area di memoria usata per le variabili globali non inizializzate), I-Data segment (segmento conenente la variabili globali inizializzate) e Text segment (segmento di testo). La differenzazione avviene copiando nello spazio di indirizzamento del processo figlio: Text segment nell'area Text, Ampiezza BSS + I-Data segment in Data e l'indirizzo della prima istruzione del main nel PC. Inoltre vengono preservete le variabili di ambiente (vedremo avanti). Per finire possono cambiare alcuni attributi del processo: gestione dei segnali --> resettata a default, userID e groupID --> modificati solo se indicato nell'eseguibile, segmenti di memoria condivisa e semafori posix.
04.4) Proprieta' delle exec: return: in caso di successo non ritorna perche' e' stata chiamata in un programma che e' ormai stato sovrascritto dal nuovo eseguibile, altrimenti -1 (e setta errno).
04.5) Non serve l'if: perche' tanto, se l'exec va a buon fine, non esegue la gestione dell'errore! Esempio: execl("/bin/echo", "echo", "the", "lazy", "dogs", (char*)NULL);	perror("in execl");
04.6) fflush(stdout): va eseguito prima di una exec se vengono omesse delle esecuzioni precedenti all'exec stessa.
05.0) Sintassi: int execl(char *path, char *arg0, char *arg1, ...) --> *path: percorso per l'eseguibile --> *arg0: nome del file eseguibile --> *arg1,...,*argN: facoltativo, sarannoo accessibili successivamente nel nuovo codice (funzioni ad argomenti variabili) --> return: nessuno, altrimenti -1 (e setta errno).
05.1) Per altre exec consultare "man exec".
06.0) Sintassi: void exit(int status) --> status: stato di terminazione (indica il motivo della terminazione e fara' cose diverse in base allo status) --> return: nessuno --> effect: terminazione del processo.
06.1) Terminazione di processi: quattro modi possibili: per exit(), per _exit() o _Exit(), per ricezione di un segnale o per system crash. Oss: sono tutte in stdlib.h tranne _exit() che e' in unistd.h.
06.2) Chiamata di atexit(): alla fine dell'esecuzione della funzione exit() avviene la chiamata ad atexit() che ha il compito di: eliminare dati temporanei, ritorna al padre, stampa messaggi dell'esito della cancellazione e altre cose.. . La cancellazione delle funzioni avviene in ordine inverso.
07.0) Sintassi: void _exit(int status) --> status/return: stesse cose della exit() --> effect: terminazione del processo, chiusura di tutti i file descriptors, libera lo spazio di indirizzamento, invia un segnale al padre (SIGCHLD), salva il byte meno significativo della variabile status nella Tabella dei Processi in attesa che il padre recepisca il segnale di terminazione e il PPID del processo terminato (quindi il PID del padre del processo terminato) diventera' = 1 (1 indica che il processo e' stato affidato a INIT (detti processi orfani).
08.0) Sintassi: int wait(int *statusp) --> *statusp: puntatore allo status che indica il tipo di attesa (se NULL fara' un qualcosa stabilito di default) --> return: PID in caso di successo, altrimenti -1 (e setta errno).
08.1) OSS: corrisponde a waitpid con PID = -1 e privo di opzioni (waitpid: vedi 9.0).
09.0) Sintassi: int waitpid(pid_t pid, int *statusp, int options) --> pid: PID del figlio da aspettare, se pid>0 ==> attende il figlio con quel PID, se pid=0 ==> attende un qualsiasi processo figlio dello stesso process group, se pid=-1 attende un qualsiasi figlio, se pid<-1 ==> attende il figlio con PID cambiato di segno --> *statusp: puntatore allo stato restituito dalla exit, ovvero il primo byte della variabile status passata alla exit (serve per memorizzare lo status), oltre ad altre informazioni accessibili tramite maschere (se NULL accetta il primo figlio che termina) --> options: serie di flags combinati con "|" (OR) che permettono di rendere (ad esempio) la wait non bloccante WNOHANG (ovvero continua l'esecuzione senza aspettare il figlio), se = 0 e' come se non ci fossero flags --> return: PID o 0 in caso di successo, altrimenti -1 (e setta errno).
09.1) statusp: inizialmente e' una variabile non inizializzata, viene passata alla wait affinche' la modifichi per poter consultare lo stato della exit del processo figlio. Esempio: int status;   waitpid(-1,&status,0); . I controlli su status avvengono con delle macro: (WIFEXITED(status) == true) ==> terminazione avvenuta con exit o return, (WIFSIGNALED(status) == true) ==> processo terminato a causa di un segnale, (WCOREDUMP(status) == true) ==> terminazione a causa di core dumped (di file), (WIFSTOPPED(status) == true) ==> processo stoppato (quindi messo in attesa _credo_), WEXITSTATUS(status) ==> ritorna lo stato perche' protetto da maschere, WTERMSIG(status) ==> ritorna il segnale che ha causato la terminazione.
09.2) Processo Zombie: c'e' se il processo termina ma il processo padre non fa la waitpid. Quindi il processo figlio occupa ancora la Tabella dei Processi perche' nessuno l'ha rimosso.
09.3) Rischio Deadlock e Processi Zombi: chiamate a waitpid con pid=-1 o semplicemente wait, puo' causare problemi seri perche' non sappiamo quale figlio termina e quindi lo stato ottenuto e' di un figlio qualunque. Non sappiamo gestirli al meglio!

