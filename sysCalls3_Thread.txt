sysCalls: 0) void* (come usarlo), 1) pthread_create, 2) pthread_join, 3) pthread_exit, 4) pthread_mutex_lock, 5) pthread_mutex_unlock, 6) pthread_cond_signal, 7) pthread_cond_wait, 8) pthread_cancel, 9) pthread_cleanup_push, 10) pthread_cleanup_pop, 100) Interferenze/Semafori, 101) Controlli degli errori nei thread, 102) Compilazione di programmi con thread, 103) Condition Variables (riguardo alle syscalls numero 6 e 7). Le #include sono: pthread.h,
0.0) void*: per tutti gli argomenti di tipo void* delle funzioni pthread e' necessario un cast esplicito per poter essere usati e per essere passati!
0.1) Esempi: --> pthread_create(&tid,NULL,&myfun,(void*)4); ==> (void*)4: perche' l'argomento e' di tipo void* ma 4 e' int. --> pthread_join(tid,(void*) &status); ==> (void*) &status perche' l'argomento e' di tipo void* ma status e' di tipo int.
0.2) Controllo che lo spazio sia sufficiente per rappresentare un intero: assert(sizeof(int) <= sizeof(void*));
0.3) Se una funzione ha come ritorno un tipo void*: dobbiamo fare una return con cast esplicito: return (void*)0;
01.0) Sintassi: int pthread_create(pthread_t *thread_id, const pthread_attr_t *attr, void* (*start_fcn) (void *), void *arg) --> thread_id: ID del nuovo thread --> *attr: attributi passati dal processo al thread (noi passeremo sempre "NULL" e quindi vengono passati quelli di default) --> void* start_fcn(void* arg): funzione con argomenti "arg" passati a pthread_create che contiene il codice che verra' eseguito sul thread --> effects: crea un nuovo thread, esegue il codice nella funzione passatagli ed assegna a thread_id l'ID del thread creato --> return: 0 in caso di successo, altrimenti un numero che corrsponde ad un codice d'errore (e NON setta errno).
01.1) Oss: --> Errno: il thread creato ha una propria copia di errno. --> static: le variabili definite static sono condivise tra tutti i thread (quindi immagino anche le funzioni).
01.2) Esempio di utilizzo: if( err = pthread_create(&tid, NULL, &myfun, NULL) != 0) { /* errore */ } else { /* thread creato, fai fare qualcosa al padre */ }.
02.0) Sintassi: int pthread_join(pthread_t thread_id, void **status_ptr) --> thread_id: ID del nuovo thread --> **status_ptr: quando la funzione termina la sua esecuzione status_ptr conterra' lo stato della terminazione del thread con l'ID specificato --> effects: sospende il processo che invoca la funzione finche' non termina il thread corrispondente all'ID passato alla funzione per poi liberare (al momento della terminazione di tale thread) la memoria occupata dal thread --> return: 0 in caso di successo, altirmenti un numero corrispondente ad un codice d'errore (e NON setta errno).
02.1) Rischio Memory Leak: non chiamare la pthread_join causa memory leak perche' al momento della temrinazione di un thread questo aspetta a liberare la memoria finche' non viene chiamata la pthread_join.
02.2) int pthread_detach( /*stessi arg*/ ): libera le risorse senza aspettare il join, quindi quando termina il thread vengono immediatamente liberate le risorse.
02.3) La join va chiamata dal processo principale affinche' attenda che l'esecuzione del thread finisca.
03.0) Sintassi: void pthread_exit(void *retval) --> *retval: valore di ritorno, e' passato per argomento perche' viene chiamata nel thread! Non nel processo principale --> effects: termina l'esecuzione del thread --> return: nessun ritorno (se non con *retval).
03.1) Tipi di terminazione di un Thread: --> chiamando la pthread_exit nel thread stesso --> invocando la return nel processo principale --> attraverso una chiamata di funzione da un altro thread.
03.2) Perche' salva lo stato: perche' cosi puo' essere recuperato con una join.
04.0) Sintassi: int pthread_mutex_lock(pthread_mutex_t *mutex) --> *mutex: e' la chiave --> effects: permette di acquisire la mutua esclusione --> return: 0 in caso di successo, altrimenti un codice d'errore (e NON setta errno).
04.1) Cosa succede se la chiave e' gia' settata da un altro thread? Il thread chiamante si mette in attesa finche' il la chiave non viene rilasciata.
04.2) Cosa succede se ci sono piu' thread in attesa della chiave? Viene assegnata ad uno di questi che viene risvegliato.
04.3) Inizializzazione di mutex: dovra' essere una variabile globale statica e verra' fatto con la seguente macro: "static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;". Altrimenti va chiamata la funzione pthread_mutex_init(pthread_mutex_t *mtx, const pthread_mutexattr_t *attr, ...); passandogli mutex.
05.0) Sintassi: int pthread_mutex_unlock(pthread_mutex_t *mutex) --> *mutex: e' la chiave passata precedentemente a pthread_mutex_lock --> effects: rilascia la mutua esclusione --> return: 0 in caso di successo, altrimenti un codice d'errore (e NON setta errno).
06.0) Sintassi: int pthread_cond_signal(pthread_cond_t *cond) --> *cond: contiene un valore true o 1 (ad esempio) che segnala al thread che l'evento si e' verificato (ma se nessuno e' in attesa del segnale viene persa!) --> return: 0 in caso di successo (segnale ricevuto dal thread), altrimenti un codice d'errore (e NON setta errno).
06.1) Inizializzazione di cond: cond e' la Condition Variable e deve essere inizializzata, dopo averla dichiarata globale e statica(forse), con la seguente macro: "pthread_cond_t cond = PTHREAD_COND_INITIALIZER;". Se non e' stata definita come globale useremo la seguente syscall: int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr).
07.0) Sintassi: int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mtx) --> Premessa: questa syscall deve essere chiamata dopo aver fatto la lock acquire --> *cond: variabile contenente il valore della condizione (condiz. verificata o condiz. non verificata) --> effects: il thread si mette in attesa che in un altro thread venga chiamata la funzione pthread_cond_signal affinche il thread corrente riceva il segnale --> return: 0 in caso di successo, altrimenti un codice d'errore (e NON setta errno).
07.1) Utilizzo: di solito si mette in un while (e sempre in mutua esclusione) perche' il segnale inviato dall'altro thread potrebbe essere recepito da uno degli altri thread in attesa. Di conseguenza al thread corrente e' come se arrivasse un segnale "negativo" (di conseguenza va rimesso in attesa del segnale successivo).
08.0) Sintassi: int pthread_cancel(pthread_t *tid) --> *tid: ID del thread che dovra' terminare --> return: 0 in caso di successo, altrimenti un codice d'errore (e NON setta errno).
08.1) Cancellation Points: quando un thread chiama la cancel su un altro thread questo verra cancellato su di un cancellation point, ovvero una chiamata di funzione che permette la terminazione del thread (es: pthread_cond_wait e' un punto di cancellazione). --> Problema grave: se la terminazione avviene su un punto di cancellazione in mutua esclusione, la terminazione avviene quando il thread e' ancora in possesso della lock (non avendola ancora rilasciata). Per questo dobbiamo, per ovviare al problema, chiamare al momento della cancellazione delle funzioni dette Cleanup Handlers (guarda 9.0 e 10.0).
09.0) Sintassi: void pthread_cleanup_push(void (*handler) (void*), void *arg) --> void handler(void *arg): funzione di cleanup che prende come argomento l'arg passato alla funzione --> effects: prepara la funzione ad essere eseguita la quale fara': lo sblocco della lock, la free sulla memoria che occupava il thread (per evitare memory leak), la chiusura dei descrittori, ecc.. --> return: nessuno
09.1) Possibile implementazione della funzione passata: void handler(void *arg){ free(*arg);  Pthread_mutex_unlock(&mtx); }
10.0) Sintassi: void pthread_cleanup_pop(int execute) --> Premessa: deve essere chiamata dopo la push --> execute: valore che indica se eseguire oppure no la chiamata della funzione passata alla push (se 0 ==> non eseguire, se 1 ==> esegui) --> effects: esegue il conenuto della funzione passata alla push --> return: nessuno
10.1) Utilizzo: L'ordine di chiamata delle funzioni deve essere il seguente: pthread_cleanup_push, pthread_mutex_lock, pthread_mutex_unlock, pthread_cleanup_pop.
10.2) Quando usare pop e push? E' meglio, se possibile, non usarle ma in alcuni casi e' necessario. Se possibile facciamo terminare un thread con una exit o un return, altrimenti con push/pop.

100.0) Interferenze: se piu' thread lavorano su dati condivisi possono causare la perdita di questi.
100.1) Risoluzione al problema: mettere sempre in mutua esclusione i thread che devono modificare dati condivisi. I semafori permettono la mutua esclusione.
100.2) Semafori: con le mutex, ovvero funzioni di pthread.h che permettono la lock acquire: pthread_mutex_lock e pthread_mutex_unlock. Il codice con le chiamate lock/unlock che usa variabili condivise e' consigliabile incapsularlo in una funzione static accessibile a tutti i thread al cui interno sono a loro volta definite static le variabili condivise.
101.0) Come controllare gli errori nei thread: if( (err=pthread_mutex_lock(mtx)) != 0) { errno=err; perror("lock"); pthread_exit(errno); } else { printf("locked"); }
102.0) Compilazione di programmi c con thread: gcc prog.c -lpthread.
103.0) Condition Variables: servono quando due thread lavorano su dati condivisi e uno dei due deve fare operazioni dopo le operazioni fatte dall'altro thread. Se i due thread hanno tempi di lavoro diversi il thread piu' veloce fa controlli inutili sprecando tempo e risorse. Per questo usiamo delle variabili condizione da passare alle due syscalls pthread_cond_signal e pthread_cond_wait che comunichera' al thread piu' veloce se l'operazione e' stata fatta oppure no (guarda 6.0 e 7.0).
